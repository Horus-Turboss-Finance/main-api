import { handleDBError } from "../utils/handleCoreResponse";
import { Roles } from "../types/@types.roles";
import { DBConnection } from "../config/db";
import { Table } from "ts-sql-query/Table";
import { createHmac } from "crypto";

const base64Encode = (data: string) => Buffer.from(data, 'utf-8').toString('base64url');
const base64Decode = (data: string) => Buffer.from(data, 'base64url').toString('utf-8');

const tUser = new (class extends Table<DBConnection, "tUser"> {
  id = this.autogeneratedPrimaryKey("id", "int");
  pseudo = this.column("pseudo", "string");
  name = this.column("name", "string");
  email = this.primaryKey("email", "string");
  password = this.column("password", "string");
  // authKey = this.optionalColumn("auth", "string");
  role = this.column("role", "string");
  avatar = this.column("avatar", "string");
  deletedAt = this.optionalColumn("deletedat", 'localDate');
  constructor() {
    super("user");
  }
})();

const selectBase = {
  id: tUser.id,
  name: tUser.name,
  role: tUser.role,
  email: tUser.email,
  pseudo: tUser.pseudo,
  avatar: tUser.avatar,
};

class TokenService {
  static generate({ email, id, role }: { email: string; id: number; role: string }) {
    const dataPart = base64Encode(JSON.stringify({ email, id, role }));
    const validityPart = base64Encode(`${Date.now()}`);

    const baseSignedPart = `${dataPart}.${validityPart}`;

    const hmac = createHmac("sha256", process.env.SIGNEDTOKENSECRET ?? "");
    hmac.update(baseSignedPart);

    const signedToken = hmac.digest("base64url");

    return `${baseSignedPart}.${signedToken}`;
  }

  static decode(token: unknown): { email: string; id: number; role: string; valid: boolean } {
    if (!token) throw "No token provided";
    if (typeof token !== "string") throw "Token isn't a string";

    const [dataPart, validityPart, signedPart] = token.split(".");

    if (!dataPart || !validityPart || !signedPart) throw "Invalid token";

    const baseSignedPart = `${dataPart}.${validityPart}`;

    const hmac = createHmac("sha256", process.env.SIGNEDTOKENSECRET ?? "");
    hmac.update(baseSignedPart);

    const signedToken = hmac.digest("base64url");
    if (signedPart !== signedToken) throw "Invalid token";

    return {
      ...JSON.parse(base64Decode(dataPart)),
      valid:
        Date.now() -
          parseInt(process.env.VALIDTIMETOKEN ?? `${1000 * 60 * 60}`) <
        parseInt(base64Decode(validityPart)),
    };
  }
}

export class User {
  static async insert(data: { name: string; email: string; pseudo: string; avatar: string; password: string }) {
    await new DBConnection()
      .insertInto(tUser)
      .set({ ...data, role: Roles.USER })
      .executeInsert()
      .catch(handleDBError("insert", "user"));

    return this.generateToken(await this.findByEmail({ email: data.email }));
  }

  static async login({ email }: { email: string }) {
    const user = await new DBConnection()
      .selectFrom(tUser)
      .where(tUser.email.equals(email))
      .select({
        id: tUser.id,
        role: tUser.role,
        email: tUser.email,
        password: tUser.password,
        isDeleted: tUser.deletedAt.isNotNull()
      })
      .executeSelectOne()
      .catch(handleDBError("login", "user"));

    if (!user) throw new Error("404");

    return {
      password: user.password,
      token: this.generateToken({ email: user.email, id: user.id, role: user.role }),
      deleted: user.isDeleted
    };
  }

  static async loginById ({ id }: { id: number}) {
    const user = await new DBConnection()
      .selectFrom(tUser)
      .where(tUser.id.equals(id))
      .select({
        password: tUser.password,
      })
      .executeSelectOne()
      .catch(handleDBError("loginById", "user"));

    if (!user) throw new Error("404");

    return user.password;
  }

  static async findByEmail({ email }: { email: string}) {
    return new DBConnection()
      .selectFrom(tUser)
      .where(tUser.email.equals(email))
      .select(selectBase)
      .executeSelectOne()
      .catch(handleDBError("findByEmail", "user"));
  }

  static async findById({ id }: { id: number }) {
    return new DBConnection()
      .selectFrom(tUser)
      .where(tUser.id.equals(id))
      .select(selectBase)
      .executeSelectOne()
      .catch(handleDBError("findById", "user"));
  }

  static async updateById({ id, data }: { id: number; data: Partial<{ name: string; pseudo: string; email: string }> }) {
    await new DBConnection()
      .update(tUser)
      .set({
        ...(data.name && { name: data.name }),
        ...(data.pseudo && { pseudo: data.pseudo }),
        ...(data.email && { email: data.email }),
      })
      .where(tUser.id.equals(id))
      .executeUpdate()
      .catch(handleDBError("updateById", "user"));

    return this.findById({ id });
  }

  static async deleteById({ id }: { id: number }) {
    await new DBConnection()
      .deleteFrom(tUser)
      .where(tUser.id.equals(id))
      .executeDelete()
      .catch(handleDBError("deleteById", "user"));

    return true;
  }

  static async softDeleteById({ id }: { id: number }) {
    await new DBConnection()
      .update(tUser)
      .set({ deletedAt: new Date() })
      .where(tUser.id.equals(id))
      .executeUpdate()
      .catch(handleDBError("softDeleteById", "user"));

    return true;
  }
  
  static async RecoveryById({ id }: { id: number }) {
    await new DBConnection()
      .update(tUser)
      .set({ deletedAt: null })
      .where(tUser.id.equals(id))
      .executeUpdate()
      .catch(handleDBError("RecoveryById", "user"));

    return true;
  }

  static async UpdatePass({ id, password }: { id: number, password: string }) {
    await new DBConnection()
    .update(tUser)
    .set({ password : password})
    .where(tUser.id.equals(id))
    .executeUpdate()
    .catch(handleDBError("UpdatePass", "user"))

    return this.findById({ id });
  }

  static decodeToken = TokenService.decode;
  private static generateToken = TokenService.generate;
}
