import { handleDBError } from "../utils/handleCoreResponse";
import { DBConnection } from "../config/db";
import { Table } from "ts-sql-query/Table";

const tTransaction = new (class extends Table<DBConnection, "tTransaction"> {
  type = this.column("type", "string"); // 'credit' | 'debit'
  userId = this.column("user_id", "int");
  date = this.column("date", "localDate");
  status = this.column("status", "string"); // 'pending' | 'completed' | 'failed'
  amount = this.column("amount", "double");
  id = this.autogeneratedPrimaryKey("id", "int");
  bankId = this.optionalColumn("bank_account_id", "int");
  description = this.optionalColumn("description", "string");
  base_category = this.optionalColumn("base_category", "string");
  categoryId = this.optionalColumn("transaction_category_id", "int");
  
  constructor() {
    super("transaction");
  }
})();

const selectColumns = {
  id: tTransaction.id,
  date: tTransaction.date,
  type: tTransaction.type,
  userId: tTransaction.userId,
  bankId: tTransaction.bankId,
  amount: tTransaction.amount,
  status: tTransaction.status,
  categoryId: tTransaction.categoryId,
  description: tTransaction.description,
  base_category: tTransaction.base_category,
};

export type TransactionFindReturnType = {
  id: number;
  date: Date;
  type: string;
  status: string;
  userId: number;
  bankId?: number;
  categoryId?: number;
  amount: number|string;
  description?: string | undefined;
  base_category?: string | undefined;
}     

export class Transaction {
  static async findAllByUserId({ userId, limit = 150, offset = 0 }: { userId: number; limit?: number; offset?: number }) {
    return new DBConnection()
      .selectFrom(tTransaction)
      .where(tTransaction.userId.equals(userId))
      .select(selectColumns)
      .orderBy(tTransaction.date,  'desc')
      .limit(limit)
      .offset(offset)
      .executeSelectMany()
      .then((v: TransactionFindReturnType[]) => {
        return v.map((aV) => {
          aV.amount = Number(aV.amount)/100;
          return aV
        })
      })
      .catch(handleDBError("findAllByUserId", "transaction"));
  }

  static async findById({ id, userId }: { id: number; userId: number }) {
    return new DBConnection()
      .selectFrom(tTransaction)
      .where(tTransaction.id.equals(id).and(tTransaction.userId.equals(userId)))
      .select(selectColumns)
      .executeSelectOne()
      .then((v: TransactionFindReturnType) => {
        v.amount = Number(v.amount)/100;
        return v
      })
      .catch(handleDBError("findById", "transaction"));
  }

  static async insert({
    userId,
    bankId,
    categoryId,
    baseCategory,
    amount,
    type,
    status,
    date,
    description
  }:{
    userId: number;
    bankId?: number;
    categoryId?: number;
    baseCategory?:string;
    amount: number;
    type: "credit" | "debit";
    status: "pending" | "completed" | "failed";
    date: Date;
    description?: string;
  }) {
    return new DBConnection()
      .insertInto(tTransaction)
      .set({
        userId,
        bankId,
        categoryId,
        base_category: baseCategory,
        amount: parseInt(`${amount*100}`),
        type,
        status,
        date,
        description
      })
      .executeInsert()
      .catch(handleDBError("insert", "transaction"));
  }

  static async updateById({ id, userId, data }: { id: number; userId: number; data: Partial<{
    bankId: number;
    categoryId: number;
    amount: number;
    type: "credit" | "debit";
    status: "pending" | "completed" | "failed";
    baseCategory:string;
    date: Date;
    description?: string;
  }> }) {
    await new DBConnection()
      .update(tTransaction)
      .set({
        ...(data.bankId !== undefined && { bankId: data.bankId }),
        ...(data.categoryId !== undefined && { categoryId: data.categoryId }),
        ...(data.baseCategory !== undefined && { base_category: data.baseCategory }),
        ...(data.amount !== undefined && { amount: parseInt(`${data.amount*100}`) }),
        ...(data.type && { type: data.type }),
        ...(data.status && { status: data.status }),
        ...(data.date && { date: data.date }),
        ...(data.description && { description: data.description }),
      })
      .where(tTransaction.id.equals(id).and(tTransaction.userId.equals(userId)))
      .executeUpdate()
      .catch(handleDBError("updateById", "transaction"));

    return this.findById({ id, userId });
  }

  static async deleteById({ id, userId }: { id: number; userId: number }) {
    await new DBConnection()
      .deleteFrom(tTransaction)
      .where(tTransaction.id.equals(id).and(tTransaction.userId.equals(userId)))
      .executeDelete()
      .catch(handleDBError("deleteById", "transaction"));
    return true;
  }

  // Vérifie si des transactions existent pour un compte bancaire
  static async existsByAccountId({ id, userId }: { id: number; userId: number }): Promise<boolean> {
    const res = await new DBConnection()
    .selectFrom(tTransaction)
    .where(tTransaction.bankId.equals(id).and(tTransaction.userId.equals(userId)))
    .select({id: tTransaction.id})
    .limit(1)
    .executeSelectMany()
    .catch(handleDBError("existsByAccountId", "transaction"));

    return res.length > 0
  }

  // Vérifie si des transactions existent pour une catégorie
  static async existsByCategoryId({ id, userId }: { id: number; userId: number }): Promise<boolean> {
    const res = await new DBConnection()
    .selectFrom(tTransaction)
    .where(tTransaction.categoryId.equals(id).and(tTransaction.userId.equals(userId)))
    .select({id: tTransaction.id})
    .limit(1)
    .executeSelectMany()
    .catch(handleDBError("existsByAccountId", "transaction"));

    return res.length > 0;
  }
}
