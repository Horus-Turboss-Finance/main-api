import { handleDBError } from "../utils/handleCoreResponse";
import { DBConnection } from "../config/db";
import { Table } from "ts-sql-query/Table";

const tBankAccount = new (class extends Table<DBConnection, "tBankAccount"> {
  id = this.autogeneratedPrimaryKey("id", "int");
  userId = this.column("user_id", "int");
  label = this.column("label", "string");
  type = this.column("type", "string");
  balance = this.column("balance", "int");
  icon = this.column("icon", "string");
  constructor() {
    super("bank_account");
  }
})();

const selectColumns = {
  id: tBankAccount.id,
  label: tBankAccount.label,
  type: tBankAccount.type,
  balance: tBankAccount.balance,
  icon: tBankAccount.icon,
};

type hackType = {
  id: number;
  balance: number|string;
  type: string;
  label: string;
  icon: string;
}     

export class BankAccount {
  static async findAllByUserId({ userId }: { userId: number }) {
    return new DBConnection()
      .selectFrom(tBankAccount)
      .where(tBankAccount.userId.equals(userId))
      .select(selectColumns)
      .executeSelectMany()
      .then((v : hackType[]) => {
         return v.map((aV) => {
          aV.balance = Number(aV.balance)/100;
          return aV
        })
      })
      .catch(handleDBError("findAllByUserId", "bank"));
  }

  static async findById({ id, userId }: { id: number; userId: number }) {
    return new DBConnection()
      .selectFrom(tBankAccount)
      .where(tBankAccount.id.equals(id).and(tBankAccount.userId.equals(userId)))
      .select(selectColumns)
      .executeSelectOne()
      .then((aV:hackType) => {
          aV.balance = Number(aV.balance)/100;
          return aV
      })
      .catch(handleDBError("findById", "bank"));
  }

  static async insert({ userId, label, type, balance, icon }:{ userId: number; label: string; type: string; balance: number; icon: string }) {
    return new DBConnection()
      .insertInto(tBankAccount)
      .set({
        balance: parseInt(`${balance*100}`),
        userId,
        label,
        icon,
        type, 
      })
      .executeInsert()
      .catch(handleDBError("insert", "bank"));
  }

  static async updateById({ id, userId, data }: { id: number; userId: number; data: Partial<{label: string, balance: number}> }) {
    await new DBConnection()
      .update(tBankAccount)
      .set({
        ...(data.label && { label: data.label }),
        ...(data.balance !== undefined && { balance: parseInt(`${data.balance*100}`) }),
      })
      .where(tBankAccount.id.equals(id).and(tBankAccount.userId.equals(userId)))
      .executeUpdate()
      .catch(handleDBError("updateById", "bank"));

    return this.findById({ id, userId });
  }

  static async deleteById({ id, userId }: { id: number; userId: number }) {
    await new DBConnection()
      .deleteFrom(tBankAccount)
      .where(tBankAccount.id.equals(id).and(tBankAccount.userId.equals(userId)))
      .executeDelete()
      .catch(handleDBError("deleteById", "bank"));
    return true;
  }
}
